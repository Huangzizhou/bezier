(* ::Package:: *)

(* ::Title:: *)
(*B\[EAcute]zier subdivision pre-computations*)


CloseKernels[];
LaunchKernels[6];


(* ::Input:: *)
(*(*Order*)*)
(*degreeLexicographicQ[a_List,b_List]:=Module[{ta,tb},ta=Total[a];tb=Total[b];If[ta==tb,a<b,ta<tb ]];*)
(**)
(*(*Variable names*)*)
(*VarSet[n_Integer]:=Take[{X,Y,Z,W},n];*)
(*VarSetT[n_Integer]:=Append[VarSet[n],T];*)
(**)
(*(*Index set for the jacobian*)*)
(*IndexSetJ[n_Integer,s_Integer,p_Integer]:=Sort[Select[*)
(*Tuples[Range[0,n*p-1],n],*)
(*(Total[Take[#,s]]<=n*p-s&&AllTrue[Drop[#,s],LessEqualThan[n*p-1]])&*)
(*],degreeLexicographicQ];*)
(*IndexSetJT[n_Integer,s_Integer,p_Integer]:=Sort[Flatten[Outer[Join,*)
(*IndexSetJ[n,s,p],List/@Table[t,{t,0,n}],1],1*)
(*],degreeLexicographicQ];*)
(**)
(*(*Domain points*)*)
(*DomainPointsT[n_Integer,s_Integer,p_Integer]:=Sort[Flatten[Outer[Join,*)
(*Map[*)
(*Join[Take[#,s]/Max[n*p-s,1],Drop[#,s]/Max[n*p-1,1]]&,*)
(*IndexSetJ[n,s,p]*)
(*],List/@Table[t,{t,0,1,1/n}],1],1*)
(*],degreeLexicographicQ];*)


(* ::Section:: *)
(*Jacobian from control points*)


(* ::Input:: *)
(*(*Univariate Lagrange Polynomial*)*)
(*LagrangeUni[q_Integer,j_Integer]:=Product[(q*\[Xi]-k)/(j-k),{k,Drop[Range[0,q],{j+1}]}];*)
(*(*Lagrange Polynomial*)*)
(*Lagrange[n_Integer,s_Integer,p_Integer,i_List]:=(LagrangeUni[p-Sum[i[[j]],{j,1,s}],p-Sum[i[[j]],{j,1,s}]]/.{\[Xi]->1-Sum[Subscript[\[Xi],j],{j,1,s}]})*Product[LagrangeUni[i[[j]],i[[j]]]/.{\[Xi]->Subscript[\[Xi],j]},{j,1,s}]*Product[LagrangeUni[p,i[[j]]]/.{\[Xi]->Subscript[\[Xi],j]},{j,s+1,n}]*)
(*(*Index set for the geometric map*)*)
(*IndexSet[n_Integer,s_Integer,p_Integer]:=Select[*)
(*Tuples[Range[0,p],n],*)
(*(Total[Take[#,s]]<=p&&AllTrue[Drop[#,s],LessEqualThan[p]])&*)
(*];*)
(*(*Single component of the geometric map at time T*)*)
(*GMComponent[n_Integer,s_Integer,p_Integer,T_Integer]:=Sum[Subscript[V,Append[i,T]]*Lagrange[n,s,p,i],{i,IndexSet[n,s,p]}]*)
(*(*Geometric map at time T*)*)
(*GeoMap[n_Integer,s_Integer,p_Integer]:=Table[((1-T)*GMComponent[n,s,p,0]+T*GMComponent[n,s,p,1])/.{V->x},{x,VarSet[n]}]~Join~{T};*)
(*(*Jacobian determinant*)*)
(*JacDet[n_Integer,s_Integer,p_Integer]:=Det[D[GeoMap[n,s,p],{Table[Subscript[\[Xi],i],{i,n}]~Join~{T}}]]*)
(**)
(*(*Lagrange Vector*)*)
(*LagVector[n_Integer,s_Integer,p_Integer]:=Module[{poly,pts,rules},*)
(*poly=JacDet[n,s,p];*)
(*pts=DomainPointsT[n,s,p];*)
(*rules[pt_]:=Table[Subscript[\[Xi],i]->pt[[i]],{i,n}]~Join~{T->pt[[n+1]]};*)
(*ParallelTable[poly/.rules[pt],{pt,pts}]*)
(*];*)
(*(*Pretty print*)*)
(*MySimplify=FullSimplify[#,Trig->False,TimeConstraint->1,ComplexityFunction->LeafCount]&;*)
(*PrintVector[n_Integer,s_Integer,p_Integer]:=Print[MatrixForm[MySimplify[LagVector[n,s,p]]]];*)
(*CExpression[n_Integer,s_Integer,p_Integer]:=Print[CForm/@MySimplify[LagVector[n,s,p]]];*)


(* ::Section:: *)
(*Subdivision matrices*)


(* ::Input:: *)
(*mapTime[point_List,shift_]:=Append[Most[point],(Last[point]+Boole[shift])/2];*)
(**)
(*mapSubdomain[point_List,q_Integer,n_Integer,s_Integer]:=Module[{res,qs,qt,k},*)
(*res=point;*)
(*If[q>=2^(n),Print["Q=",q," too large!"];Return[0]];*)
(*qs=Mod[q,2^(s)];*)
(*(*Simplex part*)*)
(*Switch[s,*)
(*0,res[[1]]=(point[[1]]+Boole[qs!=0])/2,*)
(*1,Switch[qs,*)
(*0,res[[1;;2]]=point[[1;;2]]/2,*)
(*1,res[[1;;2]]=(point[[1;;2]]+{1,0})/2,*)
(*2,res[[1;;2]]=(point[[1;;2]]+{0,1})/2,*)
(*3,res[[1;;2]]=({1,1}-point[[1;;2]])/2*)
(*],*)
(*2,Switch[qs,*)
(*0,res[[1;;3]]=point[[1;;3]]/2,*)
(*1,res[[1;;3]]=(point[[1;;3]]+{1,0,0})/2,*)
(*2,res[[1;;3]]=(point[[1;;3]]+{0,1,0})/2,*)
(*3,res[[1;;3]]=(point[[1;;3]]+{0,0,1})/2,*)
(*4,res[[1;;3]]={1-Total@point[[2;;3]],point[[2]],Total@point[[1;;3]]}/2,*)
(*5,res[[1;;3]]={1-point[[2]],Total@point[[1;;2]],Total@point[[2;;3]]}/2,*)
(*6,res[[1;;3]]={Total@point[[1;;2]],1-point[[1]],point[[3]]}/2,*)
(*7,res[[1;;3]]={point[[1]],Total@point[[2;;3]],1-Total@point[[1;;2]]}/2*)
(*],*)
(*_,Print["Not implemented"]; 0*)
(*];*)
(*(*Tensor part*)*)
(*For[k=s+2,k<=Length[point],++k,*)
(*qt=BitGet[q,k-1];*)
(*res[[k]]=(point[[k]]+Boole[qt!=0])/2;*)
(*];*)
(*Return[res];*)
(*];*)
(**)
(*matCompress[m_List]:=Prepend[*)
(*Flatten[Table[If[m[[i,j]]!=0,{i-1,j-1,Numerator[m[[i,j]]],Denominator[m[[i,j]]]},Nothing],{i,1,Length[m]},{j,1,Length[m]}]],*)
(*Length[m]*)
(*];*)
(**)
(*generateT[n_Integer,s_Integer,p_Integer]:=Module[{slackV,slackE,exponents,points,basis,mat,l2b,tbm,sdm},*)
(*(*Create basis and list of exponents*)*)
(*slackV=Join[*)
(*Append[VarSetT[n],1-Total@Take[VarSetT[n],s]],*)
(*1-Drop[VarSetT[n],s]*)
(*];*)
(*slackE=Join[*)
(*Append[VarSetT[n],n*p-s-Total@Take[VarSetT[n],s]],*)
(*n*p-1-Most[Drop[VarSetT[n],s]],*)
(*{n-Last[VarSetT[n]]}*)
(*];*)
(*exponents=IndexSetJT[n,s,p];*)
(*points=DomainPointsT[n,s,p];*)
(*basis=Table[*)
(*(Multinomial@@Append[Take[e,s],(n*p-s)-Total[Take[e,s]]])**)
(*(Times@@Table[Binomial[n*p-1,e[[i]]],{i,s+2,n}])**)
(*(Binomial[n,Last[e]])**)
(*(Times@@Power[slackV,slackE/.Thread[VarSetT[n]->e]]),*)
(*{e,exponents}*)
(*];*)
(*If[Simplify[Plus@@basis]!=1,Print["There is an error somewhere!"],Print["Partition of unity check OK"],Print[Simplify[Plus@@basis]!=1]];*)
(**)
(*(*Create matrices*)*)
(*(*Print["Matrix size: ",Length[basis]];*)*)
(*mat[ptMap_]:=Table[basis[[a]]/.Thread[VarSetT[n]->ptMap[points[[b]]]],{b,1,Length[points]},{a,1,Length[exponents]}];*)
(*(*Print["Computing Lag2Bez matrix"];*)*)
(*l2b=Inverse[mat[Identity]];*)
(*(*Print["Computing time bisection matrices"];*)*)
(*tbm=Table[l2b . mat[mapTime[#,B]&],{B,{False,True}}];*)
(*(*Print["Computing subdomain matrices (x",2^(sDim+tDim+1),")"];*)*)
(*sdm=ParallelTable[l2b . mat[mapSubdomain[#,q,n+1,s]&],{q,0,2^(n+1)-1}];*)
(**)
(*(*Output*)*)
(*Return[{MatrixForm@l2b,MatrixForm/@tbm,MatrixForm/@sdm}];*)
(*(*Return[{matCompress@l2b,matCompress/@tbm,matCompress/@sdm}];*)*)
(*]*)
(*generateT[2,2,2]*)


(* ::Section:: *)
(*Launch*)


(* ::Input:: *)
(*(*CExpression[2,2,2]*)*)
(*(*generateT[2,2,2]*)*)
(*CExpression[2,2,3]*)
